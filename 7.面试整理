1hashmap  1.8之后hashmap
2spring 底层
3cueenthashmap
4spring的设计模式
5spring的生命周期
6分布式的问题
7post和put请求
文件  post
get
多次提交最终执行结果一致
get 是幂等
put 也不是幂等貌似
post 不是
Dubbo  zu kei ber
注册时候自动监听
CAP  原理
一致性  可用性  容错性  
分布式锁  别聊  
哨兵集群  
hash list  set 你放屁  那是hash  不是hashmap
Spring 单例  启动的时候就创建出来  注入有set 构造
    或者根据需求 每次使用的时候创建一个  
学习整理
一.jvm相关内容
    .java文件到对象
    1.进行编译  .class文件
    2.classLoder对象进行  加载到jvm当中  完成编译为jvm字节码文件
    3.jvm字节码文件(指令)  调用本地环境对应系统指令  (完成跨平台的操作)
    classLoder 相关知识
    双亲委派机制,不同的classLoder对象加载的文件 他的亲属判定结果为flase
二:tree型数据结构  二分树
    1.红黑树  jdk1.8 当链表长度超8时进行使用  
    2.mysql 索引b+tree    avl树
    红黑树相比avl树，在检索的时候效率其实差不多，都是通过平衡来二分查找。但对于插入删除等操作效率提高很多。红黑树不像avl树一样追求绝对的平衡，他允许局部很少的不完全平衡，这样对于效率影响不大，但省去了很多没有必要的调平衡操作，avl树调平衡有时候代价较大，所以效率不如红黑树。
三:redis过期机制
    1.立即删除  在设置一个带有过期时间的key时进行发起一个回调  当过期时间到达立即进行删除   浪费资源
    2.惰性删除  设置过期时间的key不进行回收  当下一次操作时进行回收   浪费内存
    3.定时删除  设置默认的时间段进行扫描内存  如果发现过期的key时进行删除  折中方法
    redis中默认使用的方式为惰性删除和定时删除结合使用
    如果两者都没有进行删除  而且存在大量的过期key数据时
四:redis6种内存淘汰机制
    1、volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    2、volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    3、volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    4、allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
    5、allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    6、no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！
    4.0新增
    7.volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
    8.allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key
五:cap  是在多数据源情况下需要考虑的问题
    c:一致性   多数据源情况下 数据是否保持一致  
    a:可用性   多数据源情况下 是否都可以保持正常使用   
    p:分区容忍性  多数据源情况下  多久时限可以保持一致
    ac:必须保持一致  但是没有时限  (在保持一致之后可以使用  还是在不保持一致的前提下也可以进行使用)
    ap:必须保持可以使用  但是不保持一致   (如果在时限内没有完成是进行服务关闭 还是不需要保持一致继续运行)
    cp:必须保持一致  在时限内如果没有完成  进行服务关闭  是否容忍在时限内 数据达不到一致的情况下也进行请求受理
    只能做到  两者不能三者兼达
六:dubbo和cloud的区别
    dubbo序列化进行rpc调用   同等宽带情况下 快   开发难度高     微服务治理方案不够健全  只提供rpc  需要集成其他组件进行使用  注册中心   redis zookeeper   分布式配置  diamond   --淘宝
    cloud进行http调用     同等宽带情况下  慢     开发难度低     微服务治理方案足够健全  
        cloud核心组件
            熔断器 hystrix
            网关   zuul
            注册中心  euerka
            客户端负载均衡器  ribbon
            分布式配置 spring cloud cofing
            rpc远程调用   fegin
soa架构是否指单点登录
soa服务是否可以通过rpc+网关拦截+请求转发进行实现
什么情况下会使用 mongoDB
七:mysql隔离级别
八:spring 事务传播级别
九:redis slot
十:log4j 日志打印级别
cas
atomic原子类
es写入  取出  倒排索引  
mongoDb  字段类型没有约束  更适合存储 json数据类型  评论,点赞之类的
redis面试内容整理
    redis   sloat   16万
    redis 分布式锁  通过set加锁     set时需要带参数(1.此建如果有不让进行再次set,设置过期时间避免死锁);
    redis 内存淘汰机制  从不常用的key中进行淘汰   从有过期时间的key且不常用的进行淘汰
    redis key过期策略    立即过期(创建回调函数)   懒过期(使用时进行查看是否过期 如果过期进行淘汰)  定时过期(定时扫描过期字典表进行)
    redis 热点key处理方式 (通过正常key加随机数方式进行存储到不同的节点当中) 到不同的槽中取数据(压力分摊)
    redis 大value处理方式 分成多个块进行块文件存储 取出时取出块进行组装
    redis 持久化机制
            rdb   一段时间进行数据快照 保存整个库快照文件 效率慢    
                    fork线程什么时候创建  在进行持久化 进行快照时进行创建 进行异步持久化
            aof   保存所有的命令  不进行每次都进行快照
    redis 缓存雪崩
        大量缓存数据不可用
    redis 缓存穿刺
        大量无用数据 被进行查询    
                
mq面试内容
mq消息积压处理方式
    1.临时扩容   增加消费者进行临时处理消息
    2.增加一台消费者 进行消费(消息不进行耗时操作处理) 当并发小的时候进行数据重导进行消息处理
    3.消息丢失 ---->   批量重导
延迟队列和死信队列
死信队列   接受绑定此队列为死信队列 的消息队列的过期消息   队列过长  消息存放到死信队列
过期消息   1.队列绑定过期时间 使队列内的消息进行过期
           2.消息本身绑定过期时间      
           两者都有  采用最小值
数据库知识
mysql 存储引擎
默认使用innoDB
        innoDB默认使用  b+tree索引结构
                        常用索引结构
                            hash
                            b+tree
通过explain命令进行sql语句调优
索引浪费
    使用！=查询
    索引列使用 数字运算或函数运算
    在字符串左边使用%
事务特性
    acid
    a原子性
        一个事务为数据库操作的最小原子       要么全部完成  要么全部失败
    c一致性
        总是从一个状态到另一个状态 而不会存在中间状态
    i隔离性
        事务隔离级别
            1.读未提交      脏读    不可重复读   幻读
            2.不可重复读    不可重复读   幻读  
            3.可重复读      幻读   mysql 默认使用
            4.串行化        锁表
    d持久性
        一个事务提交之后就一直都是这个结果
redis 缓存雪崩
        大量缓存数据不可用
redis 缓存穿刺
        大量无用数据 被进行查询
cas
        atomic原子类
es写入  取出  倒排索引   
        mongoDb  字段类型没有约束  更适合存储 json数据类型  评论,点赞之类的
java锁
        乐观锁   cas模式
        自旋锁
                进行循环 获取直到设置成功
                悲观锁   重锁
                 
                 
        公平锁
                多个线程进入一个队列  进行逐个获取锁   资源浪费大  但是 不存在长时间获取不到锁的问题
        非公平锁
                多个线程抢锁  避免线程的休眠和线程的唤醒  资源浪费少  速度快  可能存在长时间获取不到锁
java线程池
        corePoolSize   核心线程数
        maxPoolSize   最大线程数量
        keepAliveTime   线程闲置时间 进行销毁
        unit:keepAliveTime  销毁的时间单位
        workQueue    等待队列
            直接提交队列   BlockingQueue   不会在等待队列进行等待  直接提交至线程池，当线程池没有足够资源时。直接进行拒绝策略
            有界任务队列   ArrayBlockingQueue 有初始化队列大小 当任务提交时直接进行创建线程,当线程数量达到corePoolSize时。进入队列进行等待。
                         当等待队列达到最大值时。再次进行创建线程,当线程数量达到最大线程数且无法完成任务时。执行拒绝策略
            无界任务队列   LinkedBlockingQueue 任务提交进入线程池 创建线程数,当线程数量达到corePollSize时进入等待队列。不再进行创建线程。
            优先任务队列；  PriorityBlockingQueue 当任务进入队列时进行 compareTo 方法比较优先级。优先级高的先被执行。同样不会再次创建线程；
        threadFactory  线程工程
        handler   拒绝策略
            当线程都被使用且  等待队列饱和时  进行任务拒绝




nacos
    nacos  作用
        1.配置中心      存储在nacos服务当中
        2.注册中心        
        3.消息总线
    nacos 替代了
        1.spring cloud config   配置中心    实现方式 配置文件存储在云端 通过消息总线的方式进行推送(git||svn)
        2.spring cloud eureka   
        3.spring cloud bus       消息总线 在消息进行推送时避免消息浪费，消息重复
    nacos便捷性
        可以直接下载release包进行简单配置  然后运行
    other
        eureka 需要在java环境自己进行引入依赖进行服务配置
        nacos 可以直接下载release包进行运行